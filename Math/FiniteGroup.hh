/// \file "FiniteGroup.hh" Base classes for finite groups
// Michael P. Mendenhall, 2019

/*
 * Simple group G: only normal subgroups are {e} and G
 * Normal subgroup N of G: gN = Ng for all g in G ("invariant under conjugation", gNg^-1 = N)
 * Non-simple: can be divided G/H, where S is a subgroup
 * Center of a group Z(G) = elements that commute with all elements in G is a normal subgroup.
 * Centralizer of g in G: set of elements that commute with g
 *
 * Direct products GxH: G, H are normal in GxH
 * Conjugacy classes, centers are Cartesian products of those for G,H
 * if A normal in G, B normal in H, then AxB normal in GxH with (GxH)/(AxB) isomorphic to (G/A)x(H/B)
 *
 * Solvable group: can be constructed from Abelian groups with extensions
 * Every group of odd order is solvable => "every finite simple group has even order unless it is cyclic of prime order."
 */

/////////////////////////
// <Semigroup> interface:
//
// typedef <element> elem_t;                // type for Semigroup element
// elem_t apply(elem_t a, elem_t b) const;  // apply semigroup operator to get c = ab

////////////////////////////////////
// <Enumerated Semigroup> interface:
// <Semigroup> plus:
//
// size_t getOrder() const;             // number of elements
// <iterator> begin() const;            // for iterating elements
// <iterator> end() const;              // for iterating elements
// size_t idx(elem_t) const;            // enumeration index for element
// elem_t element(size_t i) const;      // get enumerated element

///////////////////////////////////
// <[Enumerated] Monoid> interface:
// <[Enumerated] Semigroup> plus:
//
// elem_t identity() const; // get identity element

///////////////////////////////////
// <[Enumerated] Group> interface:
// <[Enumerated] Monoid> plus:
//
// elem_t inverse(elem_t a) const;  // return a^-1

#ifndef FINITEGROUP_HH
#define FINITEGROUP_HH

#include "EquivalenceClasses.hh"
#include <map>
using std::map;
#include <array>
using std::array;
#include <utility>
using std::pair;
#include <vector>
using std::vector;
#include <set>
using std::set;
#include <iostream>
#include <algorithm>
#include <cassert>
#include <numeric>

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

//////////////////////////////////
// basic (semi)group constructions
//////////////////////////////////

/// <Semigroup> wrapper to use '*' as operation
template<class T>
class MultiplySG {
public:
    /// element representation
    typedef T elem_t;
    /// apply a*b
    static constexpr elem_t apply(const elem_t& a, const elem_t& b) { return a*b; }
};

/// Finite (sub)-semigroup generated by elements of <Semigroup> G, as map from elements to generator combinations
template<class G, class V = vector<typename G::elem_t>>
map<typename G::elem_t, vector<int>> spanM(const V& gs, const G& GG = {}) {
    map<typename G::elem_t, vector<int>> M;
    int i = 0;
    for(auto& e: gs) M[e].push_back(i++);

    vector<typename G::elem_t> vNew;
    for(auto& x: gs) vNew.push_back(x);
    while(vNew.size()) {
        vector<typename G::elem_t> vv;
        for(auto& e0: vNew) {
            i = 0;
            for(auto& e1: gs) {
                auto e2 = GG.apply(e1,e0);
                auto it = M.find(e2);
                if(it == M.end()) {
                    auto g0 = M[e0];
                    g0.push_back(i);
                    M[e2] = g0;
                    vv.push_back(e2);
                }
                ++i;
            }
        }
        vNew = vv;
    }
    return M;
}

/// Construct <Enumerated Semigroup> from iterable list of finite-order generators in <Semigroup> G
template<class G>
class GeneratorsSemigroup: public G {
public:
    /// Underlying element type
    typedef typename G::elem_t elem_t;

    /// Constructor, from operator and generators
    GeneratorsSemigroup(const vector<elem_t>& gs, const G& GG = {}): G(GG), elems(span(gs,GG)) { }
    /// Constructor, catchall for alternative generator enumerations
    template<class V>
    GeneratorsSemigroup(const V& gs, const G& GG = {}): G(GG), elems(span<V>(gs,GG)) { }

    /// number of elements in group
    size_t getOrder() const { return elems.size(); }
    /// element index
    size_t idx(const elem_t& e) const { return std::lower_bound(elems.begin(), elems.end(), e) - elems.begin(); }
    /// indexed element
    const elem_t& element(size_t i) const { return elems[i]; }
    /// iteration range begin
    auto begin() const { return elems.begin(); }
    /// iteration range end
    auto end() const { return elems.end(); }

    /// Span of generators in G
    template<class V>
    static vector<elem_t> span(const V& gs, const G& GG = {}) {
        auto M = spanM<G>(gs,GG);
        vector<elem_t> v;
        for(auto& kv: M) v.push_back(kv.first);
        return v;
    }

protected:
    const vector<elem_t> elems; ///< enumeration of elements
};

/// Cartesian direct product group (G1,G2)
template<class G1, class G2>
class ProductGroup {
public:
    /// element identifier
    typedef pair<typename G1::elem_t, typename G2::elem_t> elem_t;

    /// Get identity element
    static constexpr elem_t identity() { return {G1::identity(), G2::identity()}; }
    /// Get order
    static constexpr size_t getOrder() { return G1::getOrder() * G2::getOrder(); }
    /// Get enumerated element
    static constexpr elem_t element(size_t i) { return {G1::element(i%getOrder()), G2::element(i/getOrder())}; }
    /// Get element inverse
    static constexpr elem_t inverse(elem_t a) { return {G1::inverse(a.first), G2::inverse(a.second)}; }
    /// Get group element c = ab
    static constexpr elem_t apply(elem_t a, elem_t b) { return {G1::apply(a.first,b.first), G2::apply(a.second,b.second)}; }
};


//////////////////////////
// iterator helper classes
//////////////////////////

/// iterator for integers 0...N-1
template<typename val_t = size_t>
class range_iterator: public std::iterator<std::forward_iterator_tag, const val_t> {
public:
    /// Constructor from grid dimensions
    range_iterator(val_t n, val_t i = {}): N(n), c(i) { }
    /// increment
    range_iterator& operator++() { c++; return *this; }
    /// comparison
    bool operator==(const range_iterator& rhs) const { return c == rhs.c; }
    /// inequality
    bool operator!=(const range_iterator& rhs) const { return !(*this == rhs); }
    /// dereference
    const val_t& operator*() const { return c; }

protected:
    const val_t N; ///< maximum
    val_t c;       ///< current value
};

/// iterator for enumerated semigroup instance
template<class G>
class esg_iterator: public std::iterator<std::forward_iterator_tag, const typename G::elem_t> {
public:
    /// Constructor from grid dimensions
    esg_iterator(const G& g, size_t i = 0): GG(g), c(i) { }
    /// increment
    esg_iterator& operator++() { c++; return *this; }
    /// comparison
    bool operator==(const esg_iterator& rhs) const { return c == rhs.c; }
    /// inequality
    bool operator!=(const esg_iterator& rhs) const { return !(*this == rhs); }
    /// dereference
    const typename G::elem_t& operator*() const { return (e = GG.element(c)); }

protected:
    const G& GG;            ///< underlying group
    size_t c;               ///< current position
    typename G::elem_t e;   ///< current element
};

/// iterator for a static enumerated semigroup class
template<class G>
class esg_siterator: public std::iterator<std::forward_iterator_tag, const typename G::elem_t> {
public:
    /// Constructor from grid dimensions
    esg_siterator(size_t i = 0): c(i) { if(c < G::getOrder()) e = G::element(c); }
    /// increment
    esg_siterator& operator++() { if(++c < G::getOrder()) e = G::element(c); return *this; }
    /// comparison
    bool operator==(const esg_siterator& rhs) const { return c == rhs.c; }
    /// inequality
    bool operator!=(const esg_siterator& rhs) const { return !(*this == rhs); }
    /// dereference
    const typename G::elem_t& operator*() const { return e; }

protected:
    size_t c;               ///< current position
    typename G::elem_t e{}; ///< current element
};

///////////////////////////////
// group analysis/decomposition
///////////////////////////////

/// Construct <Enumerated Semigroup> Cayley Table isomorphism of input <Enumerated Semigroup> G for faster group operations
template<class G>
class CayleyTable {
public:
    /// Enumerated element type
    typedef size_t elem_t;

    /// Constructor, from underlying <Enumerated Semigroup>
    CayleyTable(const G& GG = {}): order(GG.getOrder()), CT(buildCT(GG)) { }

    /// pre-calculated group operator
    elem_t apply(elem_t a, elem_t b) const { auto it = CT.find({a,b}); assert(it != CT.end()); return it->second; }
    /// get group order
    size_t getOrder() const { return order; }

    /// return (trivial!) element index
    static constexpr size_t idx(elem_t i) { return i; }
    /// indexed element
    static constexpr elem_t element(size_t i) { return i; }
    /// element iteration start
    auto begin() const { return range_iterator<elem_t>(order); }
    /// element iteration end
    auto end() const { return range_iterator<elem_t>(order,order); }

protected:
    const size_t order;                         ///< number of elements
    const map<pair<elem_t,elem_t>, elem_t> CT;  ///< Cayley Table ab -> c

    /// build Cayley Table from all element pairs
    decltype(CT) buildCT(const G& GG) {
        map<pair<elem_t,elem_t>, elem_t> m;
        elem_t i = 0;
        for(auto& e1: GG) {
            elem_t j = 0;
            for(auto& e2: GG) {
                auto k = GG.idx(GG.apply(e1,e2));
                assert(k < GG.getOrder());
                m[{i,j++}] = k;
            }
            ++i;
        }
        return m;
    }
};

/// Check for non-empty set (or ordered list) intersection
template<class S>
bool intersects(const S& s1, const S& s2) {
    auto it1 = s1.begin();
    auto it2 = s2.begin();
    while(it1 != s1.end() && it2 != s2.end()) {
        if(*it1 == *it2) return true;
        if(*it1 < *it2) ++it1;
        else ++it2;
    }
    return false;
}

/// Analysis of <Enumerated Semigroup> into element orders and conjugacy classes
template<class G>
class ConjugacyDecomposition {
public:
    /// Constructor from <Enumerated Semigroup>
    ConjugacyDecomposition(const G& g = {}) {
        build_cycles(g);
        build_conjugacy(g);
    }

    /// Display info
    void display(std::ostream& o = std::cout) {
        o << "Group with " << cycles.size() << " elements in " << conjClasses.size() << " conjugacy groups with:\n";
        for(auto& kv: conjClasses) o << "\t" << kv.second.size() << " elements\t[order " << cycles[*kv.second.begin()].size() << "]\n";
    }

    map<size_t,set<size_t>> by_order;       ///< elements (by index) grouped by order
    vector<vector<size_t>> cycles;          ///< cyclic groups generated by each element
    EquivalenceClasses<size_t> conjClasses; ///< conjugacy classes

protected:
    /// Build cycles
    void build_cycles(const G& g) {
        cycles.resize(g.getOrder());
        size_t i = 0;
        for(auto& e: g) {
            auto& v = cycles[i++];
            auto f = e;
            do {
                v.push_back(g.idx(f));
                f = g.apply(e, f);
            } while(f != e);
        }

        for(i = 0; i < cycles.size(); i++) by_order[cycles[i].size()].insert(i);
    }

    /// Build conjugacy groups
    void build_conjugacy(const G& g) {
        for(auto& os: by_order) {
            for(auto it0 = os.second.begin(); it0 != os.second.end(); it0++) {
                conjClasses.add(*it0, *it0);        // every element equivalent to itself
                for(auto it1 = std::next(it0); it1 != os.second.end(); it1++) {
                    if(conjClasses.equiv(*it0,*it1)) continue; // already found equivalence
                    for(auto& x: g) {
                        if(g.apply(x,g.element(*it0)) == g.apply(g.element(*it1),x)) {
                            // all powers of elements are conjugate
                            auto& v0 = cycles[*it0];
                            auto c1 = cycles[*it1].begin();
                            for(auto c0: v0) conjClasses.add(c0, *(c1++));
                            break;
                        }
                    }
                }
            }
        }
    }
};

///////////////
///////////////
///////////////
// Some Groups.
///////////////

/// Cyclic group on N elements
template<size_t N>
class CyclicGroup {
public:
    /// element representation
    typedef int elem_t;

    /// Get number of elements
    static constexpr size_t getOrder() { return N; }
    /// Get identity element
    static constexpr elem_t identity() { return 0; }
    /// Get index of element
    static constexpr size_t idx(elem_t i) { return i; }
    /// Get enumerated element
    static constexpr elem_t element(size_t i) { return i; }
    /// Get element inverse
    static constexpr elem_t inverse(elem_t a) { return (N-a)%N; }
    /// Get group element c = ab
    static constexpr elem_t apply(elem_t a, elem_t b) { return (a+b)%N; }
    /// element iteration start
    static constexpr auto begin() { return range_iterator<elem_t>(N); }
    /// element iteration end
    static constexpr auto end() { return range_iterator<elem_t>(N,N); }
};

/// Compile-time-evaluable factorial function
constexpr size_t factorial(size_t i) { return i > 1? i*factorial(i-1) : 1; }

/// Apply permutation p to array A
template<class A, class P>
A permute(const A& v, const P& p) {
    size_t j=0;
    auto vv = v;
    for(auto i: p) vv[j++] = v[i];
    return vv;
}

/// Symmetric Group (permutations) of N elements
template<size_t N>
class SymmetricGroup {
public:
    /// Number of elements
    static constexpr size_t order = factorial(N);
    /// Permutation representation
    typedef array<int,N> elem_t;

    /// permutation number i of N!
    static constexpr elem_t element(size_t i) {
        elem_t p = identity();
        if(!i) return p;

        auto nsub = factorial(N-1);
        auto j = i/nsub;
        if(j) std::swap(p[j-1], p[N-1]);
        return permute(p, SymmetricGroup<N-1>::element(i%nsub));
    }

    /// enumeration index for permutation
    static constexpr size_t idx(const elem_t& e) {
        array<int,N-1> e0{};
        size_t i = 0;
        size_t j = N;
        for(auto& c: e0) {
            c = e[i++];
            if(c == N-1) j = c = e[N-1];
        }
        return SymmetricGroup<N-1>::idx(e0) + (j < N? j+1 : 0)*factorial(N-1);
    }

    /// group order
    static constexpr size_t getOrder() { return order; }

    /// identity element
    static constexpr elem_t identity() {
        elem_t p{};
        int i = 0;
        for(auto& x: p) x = i++;
        return p;
    }

    /// Get element inverse
    static constexpr elem_t inverse(elem_t a) {
        elem_t e{};
        int j = 0;
        for(auto i: a) e[i] = j++;
        return e;
    }

    /// Get group element c = ab
    static constexpr elem_t apply(elem_t a, elem_t b) { return permute(a,b); }

    /// element iteration start
    static constexpr auto begin() { return esg_siterator<SymmetricGroup<N>>(); }
    /// element iteration end
    static constexpr auto end() { return esg_siterator<SymmetricGroup<N>>(getOrder()); }
};
/// Null permutation special case
template<>
SymmetricGroup<0>::elem_t SymmetricGroup<0>::element(size_t) { return {}; }
/// Null permutation special case
template<>
size_t SymmetricGroup<0>::idx(const elem_t&) { return 0; }


/*
/// Alternating Group (even permutations) of N elements TODO!
template<size_t N>
class AlternatingGroup {
public:
    /// Number of elements
    static constexpr size_t order = (factorial(N)+1)/2;
    /// Permutation representation
    typedef array<int,N> elem_t;

    /// Compile-time calculation of permutation number i of _N!
    static constexpr elem_t element(size_t i) { return SymmetricGroup<N>::element(2*i); }

    /// identity element
    static constexpr elem_t identity() { return SymmetricGroup<N>::identity(); }

    /// Get element inverse
    static constexpr elem_t inverse(elem_t a) { return SymmetricGroup<N>::inverse(a); }

    /// Get group element c = ab
    static constexpr elem_t apply(elem_t a, elem_t b) { return permute(b,a); }
};
*/

/*
 * Polyhedral groups:
 * tetrahedron isomorphic to A4
 * octohedral (+cube): isormorphic to S4
 * icosohedral (+dodecahedron): isomorphic to A5
 */

#endif
